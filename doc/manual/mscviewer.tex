\documentclass[11pt, twoside, titlepage]{book}
\usepackage[hcentering,textwidth=150mm,textheight=225mm]{geometry}
\usepackage[Bjornstrup]{fncychap}
\usepackage{graphicx}
\usepackage[colorlinks=true, 
            urlcolor=blue]{hyperref}
\usepackage{mathtools} 
\usepackage{longtable}
\usepackage{makeidx}
\makeindex 

%\usepackage[margin=1in]{geometry}
\usepackage{fixltx2e} 
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usepackage{centernot}
\usepackage{listings}
\usetikzlibrary{shadows}
\usepackage[toc,page]{appendix}
\usepackage{etoolbox}
\usepackage{wrapfig}
\usepackage{tcolorbox}
\usepackage{lipsum}
\usepackage{dirtree}
\include{generated/titlepage}

\newcommand{\prog}{MSCViewer} 

\newcommand{\mscevent}{\texttt{@event}}
\newcommand{\mscentity}{\texttt{@entity}}
\newcommand{\naive}{ na\"{\i}ve}
\newcommand{\closebutton}{\includegraphics[height=.7\baselineskip]{images/close1.png}}
\newcommand{\tblimg}[1]{\raisebox{-.5\height}{\includegraphics[height=.2in]{#1}}}

\newenvironment{Sidebar}[1][r]
  {\wrapfigure{#1}{0.5\textwidth}\tcolorbox}
  {\endtcolorbox\endwrapfigure}
  
\newcommand*\keystroke[1]{%
  \tikz[baseline=(key.base)]
    \node[%
      draw, 
      fill=white,
      drop shadow={shadow xshift=0.25ex,shadow yshift=-0.25ex,fill=black,opacity=0.75},
      rectangle,
      rounded corners=2pt,
      inner sep=1pt,
      line width=0.5pt,
      font=\scriptsize\sffamily
    ](key) {#1\strut}
  ;
}

\newcommand{\todo}[1]{\textit{#1}}
\newcommand{\defterm}[1]{\textit{#1}\index{#1}}
%
\makeatletter
\newenvironment{indentation}[2]%
{ \par \setlength{\leftmargin}{#1}
  \setlength{\rightmargin}{#2}
  \advance\linewidth -\leftmargin
  \advance\linewidth -\rightmargin
  \advance\@totalleftmargin\leftmargin
  \@setpar{{\@@par}}%
  \parshape 1 \@totalleftmargin
  \linewidth \ignorespaces
}{\par}
\makeatother
%
%\title{\prog{} v1.0} \author{ Roberto Attias  \\
%    User Manual
%    }
\date{\today}  

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{lightcyan}{rgb}{0.83,0.97, 1}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{mauve},
  stringstyle=\color{dkgreen},
  %backgroundcolor=\color{lightcyan},
  %frame=shadowbox,
  %xleftmargin=2em,
  %framexleftmargin=1.5em, 
  %rulesepcolor=\color{gray},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
  escapeinside={(*}{*)}
}

\makeatletter
\renewcommand\tableofcontents{
    \if@twocolumn
      \@restonecoltrue\onecolumn
    \else
      \@restonecolfalse
    \fi
    \chapter*{\contentsname}%
        \@mkboth{%
           \MakeUppercase\contentsname}{\MakeUppercase\contentsname}%
    \@starttoc{toc}%
    \if@restonecol\twocolumn\fi
    }
\makeatother  

\titleGM


\begin{document}
%\maketitle
\clearpage
\thispagestyle{empty}

\include{tocnotoc} 

\cleardoublepage

\setcounter{page}{1}
% Hint: \title{what ever}, \author{who care} and \date{when ever} could stand 
% before or after the \begin{document} command 
% BUT the \maketitle command MUST come AFTER the \begin{document} command! 
%\maketitle


\chapter{Introduction}

\section{\prog}
\prog{} is a tool supporting visualization and analysis of message sequence
charts intended primaritly for debugging of logs/traces obtained from concurrent systems.

The tool loads a text file and interprets lines containing well known keywords representing
events and interactions occurring in entities. Lines not containing the known keywords are
ignored. From the interpreted lines a model is constructed in memory. In the GUI the tool 
shows the list of all entities for which events exist. From this list the user can 
select a subset to be shown in a sequence diagram chart. Through keyboard or mouse commands
the user can easily navigate through events and interactions, rearrange entities, search, 
and perform a number of other actions for browsing the diagram.

In addition to using the tool for visualization of traces for existing 
systems, during a design phase the user can write a concise description of one or
more flow\footnote{a formal definiton of flow will be provided later in this document.
For the time being consider it a sequence of events across one or more entities} 
in the input language, load it in the tool, and export an image to 
be used for documentation. Later on, the implemented system should produce diagrams
similar to the one defined at design time, hence this approach can be used to confirm
the system behaves as designed.

In order for a system to produce the required data for \prog{}, the program code 
need to be instrumented with syslogs, printf, traces or any other mechanism avaliable,
using the format expected by the tool for the messages.
The user can run the application and generate the input file for \prog{}, possibly
by merging together multiple generated files. 

Visual inspection of the system behavior from execution logs is useful, but doesn't
scale for debugging, as it requires a human operator familiar with the expected behavior.
When applications are large enough, their development might be distributed
across multiple teams, and possibly even geographically, with only few members
fully aware of cross-component flows. To address this problem \prog{} is 
integrated with a Python interpreter and supports execution of scripts which 
can browse the model and perform any sort of validation. In addition, a set
of classes is provided to support a concise description of expected flows.
With these mechanism the user can create script to be executed in
the tool on the model created from execution logs, automatically validating 
their correctness. Scripts can also be executed from command line, without 
any GUI visualization, supporting batch validations and product smoke-testing.

\section{Message Sequence Charts and Flows}
A large class of products and application is composed by multiple concurrent
entities. For example a web application may be composed by a front-end running
in a browser, a backend web server and a database. The user interacts with the 
frontend, which in turn interacts with the backend. The backend interacts with
the database. We refer to elements involved in the interactions as 
\defterm{Entities}, and the sequence of interactions among entities required to
perform a functionality as \defterm{Flow}. 

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.5\textwidth,natwidth=1024,natheight=600]{images/simple-flow.png}
  \caption{A simple flow example}
  \label{fig:simple-flow} 
\end{figure}  
 
Fig~\ref{fig:simple-flow} shows, as an example, the flow involving a user
logging into a server which stores users information in a database. 
In complex concurrent system multiple homogeneous or heterogeneous flows
spawning tens or hundreds of entities may be in execution at any point in time.  
  
When designing, implementing and debugging such a complex system, flows play a
very important role in the entire development cycle. 

In the design phase is fairly common to represent expected flows in a design
document through some variation of Message Sequence Charts
\footnote{for more information on Message Sequence Chart see~
\href{http://en.wikipedia.org/wiki/Message\_sequence\_chart}
{http://en.wikipedia.org/wiki/Message\_sequence\_chart}}, such as the one shown
in fig~\ref{fig:simple-flow}.

In the implementation phase the developer can sprinkle calls to a
tracing/logging \footnote{ for more information about tracing vs.
logging
see~\href{http://en.wikipedia.org/wiki/Tracing\_(software)}
{http://en.wikipedia.org/wiki/Tracing\_(software)}} infrastructure
around the main points of flows.
  
At debug time
the user can then browse the various log files and mentally reconstruct and
verify flows. If not properly supported by a tool this exercise can be complex
and time-consuming, as the user has to reassemble flows identifying relevant
information often diluted in hundreds of lines of unrelated logs. To add to this
complexity, flows may not always be purely sequential like the one shown in
fig~\ref{fig:simple-flow}. 

For example, fig~\ref{fig:concurrent-flow} shows a user requesting the
instantiation of a virtual machine to an hypotetical VM Manager. the VM Manager
requests asynchrously resources (disk space, CPU, memory) to a Resource Manager
and an image for the VM to a VM Repository. When the resources and VM image are
provided, VM Manager spawns the VM.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.5\textwidth,natwidth=1024,natheight=600]{images/concurrent-flow.png}
  \caption{A flow with two concurrent branches}
  \label{fig:concurrent-flow} 
\end{figure}  

Note that the flow could also happen in different ways. For example, 
the response from the Image Repo could reach VM Manager before the response from
the Resource Manager. The implication of this consideration is that verifying
whether a flow happened as expected doesn't always amount to simply checking
whether certain string appear in a specific total order in the logs. Sometimes
events (i.e. log lines) have only a partial order, or some parts may be
optional, for example in case of an \textit{if} vs. \textit{else} branch taken 
in the code.

Capturing flows at design time is very
important to properly document how a system composed by multiple concurrent
elements operate. Validating flows in logs of runtime executions is crucial to
guarantee a complex system is operating as expected. \prog{} was designed  to
support this.

%\section{Tracing and Logging}
%\prog{} Accepts in input is either hand written to capture a desired flow at design time,
%case the program has produced information through some infrastructure
%or generated by running code, to capture an actual execution. In the latter
%The definition of tracing and logging are not always  

\section{History and Acknowledgements}
Work on \prog{} was started around 2010 at CISCO. The idea was to develop a tool
for usage during development of the control plane for the NCS-6000, CISCO 
last-generation core router, specifically to address the problem of
automatically identifying potential problems in flows and reducing the triaging 
time and amount of resources required. While the tool was started as a personal
initiative, it has found good adoption by some communities in the company. 

Before 2010, I had worked on other tools with some common aspects, so \prog{} can
be considered the result of an effort started around 2001 
(no code or IP from those early efforts has been used in \prog{}). 

As of Sept. 2014 CISCO has gracefully consented to release \prog{} in the
open-source. 

I want to thank the following people for their ideas, suggestions, feedback and
support during development of \prog{}:

\begin{itemize}
\item Akash Deshpande and Marco Zandonadi, whose collaboration in CISCO and before
has helped shaping \prog{} to its current form;

\item Edward Conger, for his suggestions, observation and his ability to push
the boundary of \prog{} and other tools I developed;

\item the CISCO managment, in particular Sunil Khaunte, Feisal Daruwalla, Satish
Gannu, Sohyong Chong and Robert Krohn, for their support during the developement
of \prog{} and for facilitating its release as open source.
\end{itemize} 

\chapter{Getting Started} 
In this chapter we will start familiarizing with \prog{} concepts through some
examples. The files used in the examples are located in the \texttt{examples/}
directory of the distribution.

\section{Your First Sequence Diagram}
The following is a simple input file for \prog{}:
\lstinputlisting{../../examples/lst1.msc}
Each line defines an \defterm{event}, i.e. an occurrence of something relevant
in an entity. The syntax consists in the \mscevent{} token followed by a JSON
object (see \href{http://json.org/}{http://json.org/} for more information about the JSON format).

Line 1 defines a \defterm{local} event, which is not part of any interaction
with other entities. The value of the \mscentity{} key indicates the entity
this event belongs to. There is no explicit sytax to define an entity: as it
parses events, \prog{} creates entities the events belong to.

Line 2 defines an event which is part of an interaction. More specifically, this
event is the \defterm{source} (or \defterm{cause}) for the interaction, as
indicated by the presence of the \texttt{src} key. Line 3 defines a
\defterm{destination}, or \defterm{effect}, as indicated by the presence of the
\texttt{dst} key. An interaction is an ordered pair composed by a cause and an
effect event. 

\section{Running \prog}

We can now start \prog{} with this input file. Assuming the current directory is
the top directory of the  distribution, run:

\begin{lstlisting}
bin/(*\MakeLowercase{\prog}*) examples/lst1.msc
\end{lstlisting}

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.5\textwidth,natwidth=1024,natheight=600]{images/gui-ex1.png}
  \caption{\prog{} GUI with \texttt{lst1.msc} loaded.}
  \label{fig:gui-lst1}
\end{figure}

Fig.~\ref{fig:gui-lst1} shows the GUI in its initial state.  The bottom-right
area shows the content of the input file, while the top-left tree shows the various
entities. Double-click on the \texttt{producer} and \texttt{consumer} entities
to open them in the diagram area, in the top-right part of the window
(fig.~\ref{fig:gui-lst1-open}). Each entity is shown in a column, with events
interleaving each other across entities. Columns can be sorted by dragging them
from their header (the part showing the entity name), and closed by clicking on
the   \closebutton{} button. Clicking on an event selects it; the selection can
be moved to the previous/next event for an entity by pressing respectively the
\keystroke{SHIFT} \keystroke{$\uparrow$} and \keystroke{SHIFT}
\keystroke{$\downarrow$} key combinations. To navigate from a source or
destination event to the paired event in an interaction use the 
\keystroke{SHIFT} \keystroke{$\leftarrow$} or \keystroke{SHIFT} \keystroke{$\rightarrow$}.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.5\textwidth,natwidth=1024,natheight=600]{images/gui-ex2-open.png}
  \caption{The user has opened all the entities in the diagram}
  \label{fig:gui-lst1-open}
\end{figure}


Try closing the \texttt{consumer} entity by clicking on the \closebutton{}
button. As the destination entity is now closed, the interaction outgoing from
the producer is shown as an arrow stub. In this case, it is pretty obvious who the
destination entity is, but in more complex scenarios there can be hundreds of
entities, and it wouldn't be easy to know which one to open from the entities tree. In
this situation the keyboard navigation cames handy. Select the interaction stub,
then press \keystroke{SHIFT} \keystroke{$\rightarrow$}: ``pushing'' on the
tip/base of an interaction stub for which the destination/source entity is not
open causes the entity to be opened.

\section{Topological Sorting}
In the diagram in fig.~\ref{fig:gui-lst1-open} events appear in the 
same order in which they were in the file. However, this is not always
the case. Select the \texttt{File/Open...} menu item, and from the file
selection widget open the \texttt{lst2.msc} file. As shown in the input area,
this file is the same as \texttt{lst1.msc}, except that the last two lines have
been swapped. Despite the fact that the destination for the interaction is
listed before the source, opening the two entities will show the same diagram as
before: \prog{} tries to preserve cause-effect ordering among events by applying
a topological sort to the events as they're loaded. It is possible to write
input files with create circular dependencies of events, resulting in the
impossibility of performing a topological sorting. In this case \prog{} reports
an error upon loading the file and skips the sorting. This case is captured in
\texttt{lst3.msc}, shown in fig.~\ref{fig:gui-lst3}

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.5\textwidth,natwidth=1024,natheight=600]{images/gui-ex3-cycle.png}
  \caption{Diagram with circular dependencies caused by interactions}
  \label{fig:gui-lst3}
\end{figure}

\section{Timestamps}
Timestamps can be associated to events throught the \texttt{time}
key. The value can assume different formats, as shown in \texttt{lst4.msc}:

\lstinputlisting[language=Java]{../../examples/lst4.msc}
.
Regardless of the unit specified in input, \prog{} converts internally the
timestamp into nanoseconds, and visualizes them in a format that can be chosen
by the user. The default format is \texttt{hh:mm:ss,ms}, but it can be 
changed through the the \texttt{Edit/Preferences...} menu item. Fig~\ref{fig:gui-lst4}
shows timestamps visualized near events.


\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.5\textwidth,natwidth=1024,natheight=600]{images/gui-ex4-time.png}
  \caption{Diagram with timestamps associated to events.}
  \label{fig:gui-lst4}
\end{figure} 


\section{Associating Data to Events}
To associate some data to an event, use the \texttt{data} key. The value is a
JSON object that will be visualized in the bottom-right area, in the
\texttt{Data} tab. For example, loading the following input file  and selecting
the third event results in the screen as shown in fig.~\ref{fig:gui-lst5}:

\begin{minipage}{\linewidth} 
\lstinputlisting{../../examples/lst5.msc}
\end{minipage}


\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.5\textwidth,natwidth=1024,natheight=600]{images/gui-ex5-data.png}
  \caption{The Data view showing data associated to the selected event}
  \label{fig:gui-lst5}
\end{figure}

\section{Orphaned Interactions}
When collecting traces from a system it is possible that either the event
representing a cause or the one representing an effect for an interaction goes
missing. This can be caused by multiple reasons, such as the fact that a trace
has wrapped around (typically traces don't grow indefinitely, but rather wrap
around, loosing older information), or that traces for one of the two entity
involved in the interaction are not available. We will refer to interactions for
which only one of the two events is available as \defterm{Orphaned
Interactions}.
\prog{} visualizes orphaned interactions as dashed arrow stubs outgoing or
incoming into the only available event.


\chapter{\prog{} Model}
This chapter provides a more formal definition of the \prog{} model. 

\section {Entity}
An \defterm{entity} is an autonomous execution entity such as a thread or state
machine. In MSCViewer entities can be defined hierarchically. For example, in a
router a node entity might contain a process entity, containing  a thread
entity, containing a state machine entity. An entity is characterized by a name,
a unique ID and a set of events. The ID of an entity is composed by the ID of
the parent, a slash (\texttt{/}) and an identifier. In other words, entity IDs
have a namespace similar to a filesystem path.
Let's consider the example shown in table~\ref{tab:entities}:
 
\begin{center}
    \begin{table}[h]
    \centering
    \label{tab:entities}
    \begin{tabular}{ | l | l | l | l |}
    \hline
    ID & Name\\ 
    \hline
    0       & Node0 \\  
    1       & Node1 \\  
    0/1234  & Node0/DS \\
    0/1236  & Node0/DS \\
    1/1234  & Node1/DS \\
    \hline
    \end{tabular}
    \caption{Example of entities}
    \end{table}
\end{center}

Here we have two nodes, named \texttt{Node0} and \texttt{Node1}. The entity IDs
are respectively 0 and 1, while their names are \texttt{Node0} and
\texttt{Node1}. 

On the first node two processes are running, the first with PID
1234, the second with PID 1236. The IDs for the corresponding entities are
\texttt{0/1234} and \texttt{0/1236}. The processes are instances of the same
executable called DS, so the entity names are \texttt{Node0/DS} and
\texttt{Node0/DS}. 

On the second node a single instance of \texttt{DS} is running, with ID
\texttt{1/1234} and name \texttt{Node1/DS}

It's worth mentioning that \prog{} does not have any semantic knowledge of
concept such as nodes, processes, or threads, and the model could be used to
represent any kind of problem domain. \prog{} understands only the concept of
hierarchical IDS and names where elements in the hierarchy are separated by
slashes.

Some entities can have an extra attribute characterizing them as clock sources.
This indicates that the entity and all its descendants are on
the same clock domain, hence sharing the same clock. As an example, a group of
computational nodes may have a shared system clock (via software or dedicated
hardware), in which case a system root entity could be used to represent this.
In other scenarios a set of nodes may have a loose clock synchronization (for
example via NTP), in which case entities representing nodes could be clock
sources for children representing processes running on the node.


\section {Event} 
An event is an occurrence of some relevance happening to an entity. Examples of
event are the state transitions in state machines or receiving or sending a
message. An event is always characterized by a timestamp, a label, and a type.
The timestamp is relative to the clock source the entity belongs to. The label is a
human-readable message providing information about the event. They type is an
identifier representing formally the specific type of the event, used for
example to select how to visually render the event in the sequence diagram 
(see~\ref{sec:rendering}). In addition to these mandatory attributes, an event
may have a dictionary of extra attributes. Rendering code or model browsing code can retrieve these
attribute to perform special tasks.

\subsection{Events Partial Order}
\label{events-partial-order}
Theoretically all events within an clock domain are fully ordered in a
``happened-before'' relationship by their timestamp. In reality however high
event granularity, low clock resolution, or the presence of multiprocessing capabilities can result in
multiple events with the same timestamp. For example a trace may
have been generated for a computational node where have two processes have an
event happening exactly at the same timestamp. This means that model events are
a \href{http://en.wikipedia.org/wiki/Partially_ordered_set}{Partially Ordered
Set} where $ev_i < ev_j$ if at least one of the following conditions is true:

\begin{itemize}
  \item $ev_i$ and $ev_j$ belong to the same clock domain and $t(ev_i) <
   t(ev_j)$
   \item  $\exists$ an interaction $I$ such that $(ev_i \rightarrow ev_j)$ 
   \item $\exists ev_1\ldots ev_n$ such that $ev_1=ev_i,\quad ev_n=ev_j,\quad
   ev_k<ev_{k+1} \quad \forall k \in (1 \ldots n-1)$
\end{itemize}

Upon parsing the model from the input file MSCViewer applies the Kahn 
\href{http://en.wikipedia.org/wiki/Topological_sorting}{topological sorting
algorithm} according to the partial order specified above. In the algorithm
however the set $S$ set is replaced with a FIFO where elements are added in the
order in which they are defined in the input file. This, and the assumption that
the input file was sorted on timestamps, guarantees that events with the same
timestamp and no incoming edges in the graph will not be shuffled around. 

The sorted events output by the algorithm are stored in an array which reflects
the visualization order.

The topological sorting is particularly useful when the input data is produced
by entities with different clock sources. For example, an input file may be
produced by joining traces collected on two separate Linux nodes. Even when
nodes are synchronized through NTP, there may be a small drift resulting in the
tracing of a source event having a timestamp larger than the corresponding to
the tracing of the destination event. A simple merging of the two traces based
on timestamp would produce a model where cause and effect are in the opposite
order (with the arrow representing the interaction going from bottom to top).
The topological sorting takes care of this problem. Note that the timestamps
associated to the events are not modified, hence while the arrow flows from top
to bottom, the source will still show up with a timestamp greater than the
destination. Computing the actual offset between the two nodes is not trivial
if not impossible, and anyway correcting the timestamp may confuse the user. 

\section {Interaction}

An interaction is a tuple $(ev_i, ev_j, type)$ where:
\begin{itemize}
  \item $ev_i$ is called the {\it source} or {\it cause} event, and the entity
  the event belongs to is called the {\it source entity};
  \item $ev_j$ is called the {\it destination} or {\it effect} event, and the
  entity the event belongs to is called the {\it destination entity}
  \item $type$ is an identifier characterizing the nature of the interaction
  (for example \texttt{message}, or \texttt{creation})
\end{itemize}
In the model adopted interaction implies a causality between the source and
destination event, hence $(ev_i, ev_j, T) \centernot\implies (ev_j, ev_i, T)$. 

Note also that the model allows source and destination event to belong to the
same entity.

An example of interaction type is a message-passing. In this case the source
event captures the sending of the message, while the destination event captures
the reception. Another example is a state machine instantiation:
in this case the creating entity would have an ``sm instantiation'' event, while
the created state machine would have a first event corresponding to its birth.
In this case, clearly, the state machine entity would be a children of the
creator entity. An example where source and destination events belong to the
same entity is initiation and completion of a DMA operation. 
Note that the model allows for additional events
to be present between the source and destination event for an interaction.

In the model interactions are captured with an interaction ID attribute
associated to the source and destination events. This attribute has the same
value (a unique id) for events belonging to the same  interaction.

The model allows for an event to be the source of multiple interactions, but
the destination to only one interaction. events with multiple outgoing
interaction can be used, for example, to capture multicast messaging.

In this document we will in some cases use the notation $(A_{e_1} \rightarrow
B_{e_2})$ to represent an interaction between an event $e_1$ on entity $A$ and
an event $e_2$ on entity $B$

\section{Input Language}
\prog{} can load a single file containing description of events for multiple
entities and build a model in memory. The input file is composed by lines of
text. \prog{} ignores any line not containing the \mscevent{} or
\mscentity{} word. This allows to load trace files which might contain
a mix of trace lines catered to \prog{} and unrelated trace lines.

An event is described in the input language by a line containing the
\mscevent{} followed by a JSON object. If the reader is not familiar
with this format, it is explained here: \href{http://json.org/}{http://json.org/}
   
\prog interprets certain keys-value pairs in the JSON objects in order to build
the entity/event/interaction model. 

For events, the following keys are interpreted:
 

\begin{center}
    \begin{longtable}{ll}
    \hline
    \textbf{Key:}         & \texttt{entity} \\
    \textbf{Type:}        & String \\
    \textbf{Mandatory:}   & y\\
    \textbf{Example:}     & \texttt{"id":"node0/producer\_1"}\\
    \textbf{Description:} &
    \begin{minipage}[t]{0.8\columnwidth}%
        an identifier for the entity this event belongs to. identifiers can contain slash to indicate hierarchy of entities.\\
    \end{minipage}    
    \tabularnewline
    \hline
    \textbf{Key:}         & \texttt{label} \\
    \textbf{Type:}        & String \\
    \textbf{Mandatory:}   & y\\
    \textbf{Example:}     & \texttt{label":"operation competed"}\\
    \textbf{Description:} &
    \begin{minipage}[t]{0.8\columnwidth}%
        a label specifying some immediate info about this event. In MSCViewer the label is shown on the right 
        of the icon representing the event.\\
    \end{minipage}    
    \tabularnewline
    \hline
    \textbf{Key:}         & \texttt{time} \\
    \textbf{Type:}        & String \\
    \textbf{Mandatory:}   & n\\
    \textbf{Example:}     & \texttt{"time":"1542532s"}\\
    \textbf{Description:} &
    \begin{minipage}[t]{0.8\columnwidth}%
        a timestamp for the event.  It's an integer number followed by a unit qualifier: "s" (seconds), "ms" 
        (milliseconds), "us" (microseconds) or "ns" (nanoseconds). The timestamp is interpreted as elapsed time 
        since the Unix Epoch . If the timestamp is not present inside the JSON object, it is expected to be 
        present before it in one of the formats supported by syslog.  time is shown in MSCViewer at the right 
        of the event icon. \\
    \end{minipage}    
    \tabularnewline
    \hline
    \textbf{Key:}         & \texttt{type} \\
    \textbf{Type:}        & String \\
    \textbf{Mandatory:}   & n\\
    \textbf{Example:}     & \texttt{"type":"Timer"}\\
    \textbf{Description:} &
    \begin{minipage}[t]{0.8\columnwidth}%
        If present, the value specifies a distinct type for the event. Events of different types can be rendered
         by different icons in MSCViewer. Icons can be provided by a user in a directory in the form of PNG images
          whose name matches the type name. This allows to plug domain-specific representation for events.\\
    \end{minipage}    
    \tabularnewline
    \hline
    \textbf{Key:}         & \texttt{data} \\
    \textbf{Type:}        & JSON Value\\
    \textbf{Mandatory:}   & n\\
    \textbf{Example:}     & \texttt{"data":\{"v1":10, "v2":20\}} \\
    \textbf{Description:} &
    \begin{minipage}[t]{0.8\columnwidth}%
	    Specifies some data associated to the event. For example, if the event corresponds to the sending of 
	    a message, the value here could be a JSON representation of the message. in MSCViewer data is shown in 
	    a table in the data section when the event is selected.\\
    \end{minipage}    
   \tabularnewline
    \hline
    \textbf{Key:}         & \texttt{src} \\
    \textbf{Type:}        & JSON Value\\
    \textbf{Mandatory:}   & n\\
    \textbf{Example:}     & 
        \begin{minipage}[t]{0.8\columnwidth}%
            \texttt{"src":"producer\_1/123"},\\
            \texttt{"src":"\{"id":"producer\_1/123", "color":"00FF00"\}} 
        \end{minipage}  \\  
    \textbf{Description:} &
    \begin{minipage}[t]{0.8\columnwidth}%
        Interactions are pairs of events. In a pair, one event contains the src key, while the other contains the 
        dst key, both with the same value. Interactions are visualized in MSCViewer as arrows going from the source
        to the destination event. The file format doesn't mandate a particular format for the value, but the value
        should be unique for an interaction (more on this in the interaction section of this document. In the 
        simplest case the value can be a string (which is a valid JSON value). When certain aspects of the 
        rendering need to be controlled, the value can be a JSON object with an "id" key identifying the unique
         interaction, and other keys (such as "color") identifying rendering aspects.\\
     \end{minipage}   
   \tabularnewline
    \hline
    \textbf{Key:}         & \texttt{dst} \\
    \textbf{Type:}        & JSON Value\\
    \textbf{Mandatory:}   & n\\
    \textbf{Example:}     & 
        \begin{minipage}[t]{0.8\columnwidth}%
            \texttt{"dst":"producer\_1/123"},\\
            \texttt{"dst":"\{"id":"producer\_1/123", "color":"00FF00"\}} 
        \end{minipage}  \\  
    \textbf{Description:} &
    \begin{minipage}[t]{0.8\columnwidth}%
        Interactions are pairs of events. In a pair, one event contains the src key, while the other contains 
        the dst key, both with the same value. Interactions are visualized in MSCViewer as arrows going from
        the source to the destination event. The file format doesn't mandate a particular format for the value,
        but the value should be unique for an interaction (more on this in the interaction section of this 
        document. In the simplest case the value can be a string (which is a valid JSON value). When certain
        aspects of the rendering need to be controlled, the value can be a JSON object with an "id" key 
        identifying the unique interaction, and other keys (such as "color") identifying rendering aspects.\\
     \end{minipage}    
   \tabularnewline
  \hline
  \end{longtable}
\end{center}
 
 
The following table shows the keys interpreted by MSCViewer for entities:

\begin{center}
    \begin{longtable}{ll}
    \hline
    \textbf{Key:}         & \texttt{id} \\
    \textbf{Type:}        & String \\
    \textbf{Mandatory:}   & y\\
    \textbf{Example:}     & \texttt{"id":"/node0/1984"}\\
    \textbf{Description:} &
    \begin{minipage}[t]{0.8\columnwidth}%
		The unique identifier for the entity \\
    \end{minipage}    
    \tabularnewline
    \hline
    \textbf{Key:}         & \texttt{name} \\
    \textbf{Type:}        & String \\
    \textbf{Mandatory:}   & y\\
    \textbf{Example:}     & \texttt{"id":"/node0/producer\_1"}\\
    \textbf{Description:} &
    \begin{minipage}[t]{0.8\columnwidth}%
        A name for the entity. Names don't need to be unique and provide a more human-readable representation for the entity\\    
    \end{minipage}    
    \tabularnewline
	\end{longtable}
\end{center}
 
   
\chapter{\prog{}  GUI}
This chapter provides a description of all the GUI elements in \prog.

\section{The Entities Tree}

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.3\textwidth]{images/left-pane.png}
  \caption{The Entities tree}
  \label{fig:entity-tree} 
\end{figure}  

The Entities Tree is visible on the top-left are of the GUI once an input file is loaded and the \textit{Entities} tab 
is selected. This tree shows all entities defined in the input file. An entity is defined if a \mscentity{} line is 
present or if the entity is specified in the \texttt{entity} entry of a \mscevent line. Elements of an entity 
ID separated by slashes constitute nodes in the tree. Internal nodes of the tree may have event of their own, if 
they appear as the terminal element in the \texttt{entity} entry of at least one event, or not, in which case they
just represent some relationship among the child nodes. In the latter case the node is visualized in a lighter 
shade.

For example, a system may be composed by multiple processes running in different hosts. The user may decide to 
have a log file for each process, and use a \texttt{host-id/process-id} notation for entity events. In this case,
Intermediate tree nodes for host-id will be created, but clearly there will be no events associated to them.

Double-clicking on a node corresponding to an entity with at least one event opens the entity in the Sequence 
Diagram. Double-clicking on a node corresponding to an entity already opened in the Sequence Diagram causes
it to be removed from the diagram. The following legend shows the various representations of the tree nodes:

\begin{center}
    \begin{longtable}{ll}
  	\tblimg{../../src/com/cisco/mscviewer/resources/icons/32x32/entity.png}
	& entity with at least one event, currently closed in sequence diagram\\
  	\tblimg{../../src/com/cisco/mscviewer/resources/icons/32x32/entity_open.png}
	& entity with at least one event, currently open in sequence diagram\\
  	\tblimg{../../src/com/cisco/mscviewer/resources/icons/32x32/entity_faded.png}
	& entity with no event, can't be opened in sequence diagram\\
	\end{longtable}
\end{center}


\section{The Sequence Diagram}
The Sequence Diagram ais situated on the top-right part of the GUI. Entities can be opened in this area by
various user actions:
\begin{itemize}
\item double-clicking a node in the \textit{Entity Tree}, or pressing enter open the selected entity
\item double-clicking on a line in the \textit{Log File View}
\item programmatically, by Python scripts.
\end{itemize} 

Open entities can be rearranged by dragging their \texttt{Header}, the rectangle containing the entity
name.

Width for an entity column can be increased or reduced by selecting the header and pressing repreatedly the
\keystroke{+} or \keystroke{-} keys.

\section{The Log File View}
The Log File View is a tab in the bottom-right part of the GUI. This view shows the original log file that was 
parsed to create the sequence diagram model. Lines that contributed event information are highlighted in blue, 
while other lines are shown in black. Clicking on an event line selects the correspoding event, provided that the
owning entity was open in the sequence diagram area. Selecting an event in the sequence diagram causes the 
corresponding line in the Source View to be selected. Double-clicking on an event line in the Source View
causes the corresponding entity to be opened in the sequence diagram and the event selected.

Clicking and dragging in the Log View causes text to be selected. When the mouse button is released the 
currently selected test is copied in the system clipboard.

\section{The Event Data View}
Events may have associated structured data. The data associated to the selected event is shown in the Data View,
which is located inside a tab in the bottomr-right part of the GUI. 

\section{The Notes View}
In order to facilitate a debugging session the user can associate notes to events. A note associated with an
event is shown as a small yellow square on the event. Selecting the event and right-mouse-clicking the user can
checkmark the "Note Sticker" menu item to make the note visible as a sticker in the sequence diagram.
To create a note, the user selects the event and edit the note in the Notes View, which is situated in a tab
in the bottom-right part of the GUI.

 
\section{The Tool Bar}
The toolbar contains the following buttons:

\begin{center}
    \begin{longtable}{ll}
	 \multicolumn{2}{l}{\textbf{Actions}} \\
	\hline
  	\tblimg{../../src/com/cisco/mscviewer/resources/icons/32x32/load.png}
	& \begin{minipage}[t]{0.8\columnwidth}
		Loads a new input file. Pressing this button causes a file chooser to open. Selecting a file and
      	pressing ok results in the file being loaded. 
       \end{minipage}\\ \\
	\tblimg{../../src/com/cisco/mscviewer/resources/icons/32x32/reload.png}
	& \begin{minipage}[t]{0.8\columnwidth}
		Reload the present file. This command can be used if changes are made to the file after it was loaded.
	  	Note that all currently opened entities are closed before the new file is loaded.
	  	\end{minipage}\\ \\
	\tblimg{../../src/com/cisco/mscviewer/resources/icons/32x32/camera.png}
	& \begin{minipage}[t]{0.8\columnwidth}
		Captures a screenshot of the sequence diagram. The user can select whether to capture the entire model 
		(regardless of what entities are opened in the diagram), The entities currently opened, or just the 
		entities for which at least one event is highlighted.
		\end{minipage}\\ \\
	\tblimg{../../src/com/cisco/mscviewer/resources/icons/32x32/clear_highlights.png}
	& \begin{minipage}[t]{0.8\columnwidth}
		Removes any highlight set on events or interactions, whether they're on open entity or not.
		\end{minipage}\\ \\
	\tblimg{../../src/com/cisco/mscviewer/resources/icons/32x32/run.png}
	& \begin{minipage}[t]{0.8\columnwidth}
		Re-run the latest script that was executed. Scripts can be executed by double-clicking on nodes in the
		tree shown in the Script tab, but this button provides a convenient shortcut to rerun the latest script.
		\end{minipage}\\ \\
	\tblimg{../../src/com/cisco/mscviewer/resources/icons/32x32/options.png}
	& \begin{minipage}[t]{0.8\columnwidth}
		Opens a window where various program options can be configured.
		\end{minipage}\\ \\
		
		
	\multicolumn{2}{l}{\textbf{Cursor Tools}} \\
	\hline
	\tblimg{../../src/com/cisco/mscviewer/resources/icons/32x32/select.png}
	& \begin{minipage}[t]{0.8\columnwidth}
		Chooses the select tool associated to the mouse pointer. The select tool allows to select an event or
		interaction. 
		\end{minipage}\\ \\
	\tblimg{../../src/com/cisco/mscviewer/resources/icons/32x32/highlight_green.png}
	& \begin{minipage}[t]{0.8\columnwidth}
		chooses the green marker for highlighting events. When this tool is selected clicking on an event
		causes it to be highlighted in green.
		\end{minipage}\\ \\
	\tblimg{../../src/com/cisco/mscviewer/resources/icons/32x32/highlight_blue.png}
	& \begin{minipage}[t]{0.8\columnwidth}
		Same as the green highlighter, but with blue color.
		\end{minipage}\\ \\
	\tblimg{../../src/com/cisco/mscviewer/resources/icons/32x32/highlight_yellow.png}
	& \begin{minipage}[t]{0.8\columnwidth}
		Same as the green highlighter, but with yellow color.
		\end{minipage}\\ \\
	\tblimg{../../src/com/cisco/mscviewer/resources/icons/32x32/highlight_red.png}
	& \begin{minipage}[t]{0.8\columnwidth}
		Same as the green highlighter, but with red color.
		\end{minipage}\\ \\
		
		
	\multicolumn{2}{l}{\textbf{Visualization Options}} \\
	\hline
	\tblimg{../../src/com/cisco/mscviewer/resources/icons/32x32/blocks.png}
	& \begin{minipage}[t]{0.8\columnwidth}
		Shows/hides blocks. 
	  \end{minipage}\\ \\
	\tblimg{../../src/com/cisco/mscviewer/resources/icons/32x32/time.png}
	& \begin{minipage}[t]{0.8\columnwidth}
		Shows/hides event timestamps
		\end{minipage}\\ \\
	\tblimg{../../src/com/cisco/mscviewer/resources/icons/32x32/label.png}
	& \begin{minipage}[t]{0.8\columnwidth}
		Shows/hides event labels
		\end{minipage}\\ \\
    \tblimg{../../src/com/cisco/mscviewer/resources/icons/32x32/note.png}
    & \begin{minipage}[t]{0.8\columnwidth}
        Shows/hides notes associated to events
        \end{minipage}\\ \\
	\end{longtable}  
\end{center}

\chapter{Customizing \prog}
\section{Preferences}
a number of parameters affecting the GUI can be modified in the \texttt{Preferences}
dialog accessible via the \texttt{Edit/Preferences...} menu item. These include:
\begin{itemize}
\item how to interpret event timestamps where units were not specified
\item the visualized format for timestamps in the sequence diagram
\item the format for entities headers in the sequence diagram
\item colors of various GUI elements   
\end{itemize}
When any of the parameters is modified the change is immediately visible in the GUI. If
the dialog is closed by pressing the \texttt{Ok} button, then those changes become permanent.
Pressing the \texttt{Cancel} button or closing the dialog via the OS-specific window-close button
results in the original parameters being restored. 

The original parameters can also be restored without closing the dialog by pressing the \texttt{Reset}
button.
 
\section{Sessions}
While \texttt{Preferences} control program parameters irrespective of the loaded log files, some set 
of parameters can be associated to specific Log files loaded in the tool. These set of parameters, 
referrred to as \textit{Sessions}, are saved in XML files which can be reloaded later or even
transfer across different machines. Session information includes:
\begin{itemize}
\item Entities open in the sequence diagram
\item currently selected event or interaction
\item Notes associated to events
\item markers associated to events
\end{itemize}

\section{Passing Resource Sets to \prog{}}
At the time of execution \prog{} can be passed one or more directories, each one specifying a set of resources.
Resource directories are passed using the \texttt{-r} option. Directory paths should be separated using 
the OS-specific path separator character (\texttt{:} on Linux/OS-X and \texttt{;} on Windows). 
Each directory can contain one or both the following sub-directories:
\begin{itemize}
\item \texttt{renderer}: this directory can contain images in \texttt{.png} format. These images
are loaded by \prog and become available as renderer for events whose type matches the file names (without the extension).
\item \texttt{script}: this directory can contains Python scripts. These scripts are parsed by \prog and 
specially decorated functions become available for execution in the GUI. For more information 
on Python scripts see chapter~\ref{sec:python-api}. 
\end{itemize}

Consider the following example on Linux:
\begin{lstlisting}
mscviewer -r food;animals test.msc
\end{lstlisting}

\noindent where \texttt{test.msc} contains

\begin{lstlisting}
@event { "entity":"food",    "type":"bananas", "label":"bananas"}
@event { "entity":"food",    "type":"cake",    "label":"cake"}
@event { "entity":"animals", "type":"bee",     "label":"bee"}
@event { "entity":"animals", "type":"snail",   "label":"snail"}
\end{lstlisting}

\noindent and the current directory has the following directory structure:

\dirtree{% comment here is required as first char to be found must be a dot
.1 \texttt{.} . %
.2 animals/. % space after dot is required!
.3 renderer/. %
.4 bee.png. %
.4 snail.png. %
.2 food/. %
.3 renderer/. %
.4 bananas.png. %
.4 cake.png. %
}

This loads a sequence diagram where icons for various events are picked up from the \texttt{renderer}
subdirectories.

This example is present in the \texttt{examples/custom-icons} directory of the distribution, together with 
a \texttt{run.sh} script that runs it regardless of the OS in use.

\chapter{Python Integration}
One of the most powerful aspects of \prog{} is the integration with a Python interpreter
which allows to access programmatically both model as wel as GUI.

One use of this feature
consist in writing validation scripts that can browse model data and report whether a 
particular computational flow is present or not, it respects certain timing constraints, etc. 
Because the script is written once and then applied to traces produced by running the 
system multiple times, this scales the effort of an activity that otherwise would have to be
performed by one or more human beings. A tutorial on how to create flow validation scripts
using the APIs described in this chapter is provided in chapter~\ref{chp:flowdef} 

Python scripts can also be used to drive the GUI. For example, the screen captures in this 
manual are all generated automatically a build time by a Python script which loads a model,
open some entities in the sequence diagram, captures screenshots and saves them.

The interaction between the user Python script and the tool is done through APIs 
collected in a few Python files the script can import, and described in details 
in \ref{sec:python-api}.

\section{\textit{Hello World} of Python Integration}

Let's start with the smallest possible \textit{Hello World} program in Python (\texttt{examples/hello.py}):

\lstinputlisting{../../examples/hello.py}

This can be executed by \prog{} as follows:

\begin{verbatim}
$ mscviewer -b examples/hello.py examples/lst1.msc 
 Hello World
\end{verbatim}

Here we're invoking \prog{} in batch mode, passing the \texttt{hello.py} script and
a log file. The log file is not even used in this case, and the script is simply
passed to the embedded Python interpreter which runs it, producing the output on
the console. Not particularly exciting.

Let's examine next how we can interact with the model created from the log file, as
demonstrated by \texttt{examples/info.py}:

\lstinputlisting{../../examples/info.py}

\begin{verbatim}
$ bin/mscviewer -b examples/info.py examples/lst1.msc
 entity= producer label= start
 entity= producer label= produce
 entity= consumer label= consume
\end{verbatim}

This example uses the Python API to interact with the model created from the log file, 
printing out for each event the entity path and the label. The extensive set of APIs 
provided to interact with the model as well as the GUI is documented in section
\ref{sec:python-api}.

In addition to executing a single Python program in batch mode, it is possible
to define any number of Python functions that can be explicitly invoked by the
user within the GUI. To demonstrate this, let's consider the \texttt{examples/hello1/hello.py}
file:

\lstinputlisting{../../examples/hello1/hello.py}
 
In order for functions to be visible by the gui we need to place the Python file declaring them
into a package, which we can achieve by creating an empty \texttt{\_\_init\_\_.py} file in the 
directory containing the file. For this reason, the \texttt{examples/hello1} directory has
the following structure:

\hfill \break
\dirtree{% comment here is required as first char to be found must be a dot
.1 \texttt{hello1}. %
.2 \texttt{\_\_init\_\_.py}. % space after dot is required!
.2 \texttt{hello.py}. % space after dot is required!
}
\hfill \break

We can now run \prog{} as follows:

\begin{verbatim}
mscviewer -p examples/hello1 examples/lst1.msc
\end{verbatim}

Once the GUI comes up, click on the \texttt{scripts} tab. The tool will parse the Python
modules available in the path, and the visualized tree should contain a \texttt{hello1}
node representing the package. Expanding such node should reveal a leaf node representing
the \texttt{hello\_world()} function. Notice that in order for a function to show up in the
GUI tree the function has to be decorated by the \texttt{@msc\_fun} decorator. This 
allow to have various utility functions in the file that do not show up as first class
citizens in the GUI.

In order to execute the function, just double-click on its node in the tree. In this 
particular case the function takes no arguments, so it will be immediately executed producing
the expected \texttt{Hello World} output on the console. 

Let's now consider \texttt{examples/hello2/hello.py}:

\lstinputlisting{../../examples/hello2/hello.py}

This example provides three functions that will be listed in the GUI:
\begin{itemize}
\item \texttt{hello\_something()} expects an argument of type string and prints the concatenation of \texttt{'Hello '}
followed by such string. The first time we double-click on this node a dialog will open allowing us to 
provide a value for the argument. We can type \texttt{'World'} (including the apices) and press \texttt{OK}. 
This time the output will not be produced on the console, but rather in the \texttt{Script Console} tab in the 
bottom-right are of the GUI. Double-clicking on the same node again will not open the dialog again, as \prog{}
remembers the previosly passed value and uses it again.  In order to open the dialog again and change the 
value keep the \keystroke{SHIFT} key pressed while double-clicking on the node. 
\item \texttt{hello\_world()} calls the previous function passing the value of \texttt{'World'} for the argument.
\item \texttt{hello\_world\_or\_not()} has a keyword parameter. Keyword parameters have a default
value, hence double-clicking on the node executes the function with such default value for the
parameter. Again, to change such value keep the \keystroke{SHIFT} key pressed while double-clicking.
\end{itemize}

It should be noted that this particular example follows a common pattern which allows a script
to be executed in batch mode, or to provide functions to be called in interactive mode. The pattern
consists in the presence of an \texttt{if \_\_name\_\_ == '\_\_main\_\_'} statement which 
is executed when in batch mode, calling a function with default values. Also, the pattern
makes use of the \texttt{msc\_print} function to produce output: this function will direct
its output to the GUI \texttt{Script Console} view when in interactive mode, while 
falling back to printing on the console when in batch mode. We can run the 
script in batch mode with

\begin{verbatim}
mscviewer -b examples/hello2/hello.py examples/lst1.msc
\end{verbatim}


\

\section{Pyhton API}
\label{sec:python-api}

The interaction between the user Python script and the tool is done through APIs 
collected in a few Python files the script can import. The Python language doesn't 
have a concept of private vs. public API, and the technology used to integrate the 
Python interpreted in \prog{} (which is written in Java) results in all the Java 
classes being actually visible and accessible from the Python code. However the 
user should restrict itself to using the API documented in the next few sections,
as this provides better guarantees of not being modified in the future. No such 
claims are made agains any of the Java classes. 

The API is currently divided in the following modules:
\begin{itemize}
\item \texttt{msc.model} -- provides API to access entities, events and interactions in the model
\item \texttt{msc.gui} -- provides API to access the GUI 
\item \texttt{msc.utils} -- provides some utility API 
\item \texttt{msc.graph} -- provides API to access the graphing capabilities (experimental). 
\item \texttt{msc.flowdef} -- provides API to implement compact definition of expected flows and apply them
                              to the current model
\end{itemize}     
                         
\subsection{Model API}

\input{generated/python-api-model.tex}

\subsection{GUI API}
\input{generated/python-api-gui.tex}

\subsection{Flows API}
\label{sec:flow-api}
\input{generated/python-api-flowdef.tex}

\subsection{Graph API}
\input{generated/python-api-graph.tex}


\section{Flow Definition}
\label{chp:flowdef}

\prog{} provides a powerful infrastructure supporting automated flow validation.
This means that a developer can write once a concise Python script describing an expected flow,
and apply such definition to models built from traces generated a runtime by a system. This
is the basis for flow-level verification automation, which is crucial to scale at least the first
level of triaging for a system.

\subsection{Your First Flow Definition}
File \texttt{examples/flw1.py} contains a simple flow definition script. Let's look at it in detail:
\lstinputlisting{../../examples/flw1.py}

\noindent Lines 1, 2 import some packages required for flow definition. These are defined in Python files
contained in the \texttt{resources/default} directory of the \prog{} install directory.

Lines 5-7 define a function returning a flow definition. The flow definition is specified as a sequence (\texttt{fseq})
of two events (\texttt{fev}). The two parameters for each \texttt{fev()} element are respectively the entity id and
the label of the events. A model containing an ordered sequence of two events on an entity named \textit{foo}, the 
first one with label \texttt{event\_a} and the second with label \texttt{event\_b} does contain the flow specified
by function \texttt{get\_flow()}. Function \texttt{get\_flow()} returns the defined flow as an object. 

Function
\texttt{find\_flow()} at line 12 calls such function to retrieve the flow definition and repeatedly calls function
\texttt{match()} on it. the \texttt{match()} function attempts to match the flow definition to the model
currently loaded in \prog{}, starting with the model event with the index specified as the \texttt{start\_event\_idx}
parameter. In case of match, the function returns the index of the last event in the model matching one of the elements
in the flow definition, plus one. If the entire flow definition is not found in the model, then the function throws a
FlowError. If passed a starting event index corresponding to the total number of events the function returns -1. 


The \texttt{examples/flw1-match.msc} is an example of a log file containing the specified flow:
\lstinputlisting{../../examples/flw1-match.msc}

However, note that the \texttt{examples/flw1-match.msc} file also contains the specified flow:

\lstinputlisting{../../examples/flw1-match2.msc}

This is the case because \texttt{fseq} requires events to be in the specified order, but
not to be contiguous in the file, or even within the entity. 

We can test the scripts by running \prog{} in batch mode:

\begin{verbatim}
$ mscviewer -b examples/flw1.py examples/flw1-match.msc 
 Found match!
$ mscviewer -b examples/flw1.py examples/flw2-match.msc 
 Found match!
$ bin/mscviewer -b examples/flw1.py examples/flw1-nomatch.msc
 No match found ( element (foo, event_a) not found in model. )
$\end{verbatim}

\subsection{Model Elements for a Flow}

In addition to knowing that a certain flow is present in a model, you may want to discover which 
\texttt{fev} elements match which mdodel events. This can be achieved using the \texttt{get\_model\_map()}
function, as illustrated by the \texttt{examples/flw2.py} example:

\lstinputlisting{../../examples/flw2.py}

The \texttt{get\_model\_map()} function returns a map where each \texttt{fev} in the flow definition is a key,
and the event matching it is the value associated to the key. Various pieces of information 
can be stracted from the event using the \texttt{event\_} API defined in the \texttt{msc.model} module.
In this example, we print the line number where the event is defined in the input file:

\begin{verbatim}
$ bin/mscviewer -b examples/flw2.py examples/flw1-match.msc
 found match!
 fev(foo, event_b) : 2
 fev(foo, event_a) : 1
$ bin/mscviewer -b examples/flw2.py examples/flw1-match2.msc
 found match!
 fev(foo, event_b) : 4
 fev(foo, event_a) : 1
\end{verbatim}

\appendix

 
\printindex

\end{document}
